#!/usr/bin/env python

import sys, socket, select, time, json, random, math, collections

# Amount of time to wait to send
# a heartbeat
HEARTBEAT_TIME = .125

# Respond to a client's message
def handle_client_message(msgtype, mid, client_address, msg):
	global my_id
	global sock
	global state
	global current_leader

	# If we are not the leader, send a redirect message
	if not (state == "leader"):
		print "SENDING REDIRECT " + current_leader
		msg = {'src': my_id, 'dst': client_address, 'leader': current_leader, 'type': 'redirect', 'MID': mid}
		sock.send(json.dumps(msg))
	# If we are the leader, deal with the user's message
	elif state == "leader":
		if msgtype == 'get':
			handle_get_command(msg)
		elif msgtype == 'put':
			handle_put_command(msg)

# Handle when a client sends a
# get request
def handle_get_command(msg):
	global state_machine
	global my_id
	global current_leader
	global sock

	#print "RECEIVED GET REQUEST" 

	key = msg['key']
	# if the key exists, send okay message
	if key in state_machine:
		value = state_machine[key]
		response = {'src': my_id, 'dst': msg['src'], 'leader': current_leader, 'type': 'ok', 'MID': msg['MID'], 'value': value}
	# otherwise send a fail message
	else:
		response = {'src': my_id, 'dst': msg['src'], 'leader': current_leader, 'type': 'fail', 'MID': msg['MID']}
		
	sock.send(json.dumps(response))

# Handle when a client sends a put request
def handle_put_command(msg):
	global my_id
	global current_leader
	global state_machine
	global log
	global sock

	key = msg['key']
	value = msg['value']

	#print "RECEIVED PUT REQUEST"

	# for now just add to log and state machine
	# and send success
	log[key] = value
	state_machine[key] = value	

	response = {'src': my_id, 'dst': msg['src'], 'leader': current_leader, 'type': 'ok', 'MID': msg['MID']} 

	sock.send(json.dumps(response))

# Get a random number for the election
# timeout - something between 150 and 300 ms
def get_election_timeout():
	i = random.randint(150, 300)
	
	# want the number to be in ms so
	# divide by 100
	return i / 100

# Check to see if the election timeout
# has occurred
def check_election_timeout(current_time):
	global last_received_rpc
	global election_timeout

	# if a timeout has occurred, begin an election
	if current_time - last_received_rpc >= election_timeout:
		begin_election()

def check_send_heartbeat(current_time):
	global last_sent_heartbeat

	if current_time - last_sent_heartbeat >= HEARTBEAT_TIME:
		send_heartbeat_rpc()

# Begin an election
def begin_election():
	global my_id
	global state
	global current_term
	global num_votes
	global voted_for
	global current_leader
	global last_received_rpc

	print "Election started by " + my_id

	# increment term by 1
	current_term = current_term + 1

	# transition to candidate state
	state = "candidate"

	# vote for yourself
	voted_for = my_id

	# increment number of votes
	num_votes = 1

	# set current leader to ourselves
	current_leader = my_id

	# reset for election timeout
	last_received_rpc = time.time()

	# issue out request rpcs to everyone else
	send_request_vote_rpcs('FFFF')

# Send out request vote rpcs
def send_request_vote_rpcs(destination):
	global sock
	global my_id
	global current_leader
	global current_term

	print "SENDING VOTE REQUEST"

	msg = {'src': my_id, 'dst': destination, 'leader': my_id, 'type': 'request_vote', 'term': current_term}
	sock.send(json.dumps(msg))

# Send out the heartbeat rpc
def send_heartbeat_rpc():
	global my_id
	global current_term
	global sock	
	global last_sent_heartbeat
	global replica_ids

	#print "SENDING HEARTBEAT " + my_id

	last_sent_heartbeat = time.time()

	for r in replica_ids:	
		#print "SENDING HEARTBEAT"
		msg = {'src': my_id, 'dst': r, 'leader': my_id, 'type': 'append_entries', 'term': current_term, 'entries': ''}
		sock.send(json.dumps(msg))

# If a message of type request_vote is
# received, handle it here - a replica
# gets one of these messages if another
# server is trying to become a leader or
# if itself is trying to become a leader and 
# is receiving responses
def handle_request_vote_messages(msg):
	global current_term
	global current_leader
	global sock
	global num_votes
	global majority
	global voted_for
	global state
	global my_id

	# if this is a response to our election
	if 'vote_granted' in msg and state == "candidate":
		print "RECEIVED A VOTE FROM " + msg['src']

		# check the answer, only do something if yes
		if msg['vote_granted'] == 'yes' and msg['term'] == current_term and msg['leader'] == my_id:
			num_votes = num_votes + 1			
			
			# if we have enough votes to become leader
			# send out append entry messages to everyone
			if num_votes >=  majority:
				print "BECOMING LEADER " + current_leader
				state = "leader"
				send_heartbeat_rpc()							

	# if this is a message from a candidate
	else:
		# if the candidate's term number is higher
		# than ours, or if it is equal and we have not voted
		if msg['term'] > current_term or (msg['term'] == current_term and voted_for == None):
			print "sending vote yes"
			current_term = msg['term']
			current_leader = msg['leader']
			voted_for = msg['src']
			response = {'src': my_id, 'dst': msg['src'], 'leader': msg['leader'], 'type':'request_vote', 'vote_granted':'yes','term': msg['term']}
			sock.send(json.dumps(response))
		#elif not (current_leader == msg['leader']): #otherwise do not vote for them
		#	print "sending vote no"
		#	response = {'src': my_id, 'dst': msg['src'], 'leader': current_leader, 'type':'request_vote', 'vote_granted':'no', 'term': current_term}

		#sock.send(json.dumps(response))		
	
def handle_append_entries_messages(msg):
	global current_term
	global current_leader
	global state
	global my_id

	# if it is a heartbeat from a leader
	# whose term is at least as big as ours
	# make sure term/leader/state is up to date
	if msg['entries'] == '' and msg['term'] >= current_term:
		#print "RECEIVED HEARTBEAT " + my_id
		current_term = msg['term']
		current_leader = msg['src']
		state = "follower"
			
# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# The number that is considered the majority
majority = math.ceil((len(replica_ids) + 1) / 2.0)

# The state the replica is in
# this can be leader, follower or candidate
# all start as followers
state = "follower"

# Each replica has an election timeout
# which will be a random number between
# 150 and 300 ms
election_timeout = get_election_timeout()

# Keep track of when the last RPC from a
# leader was received, initialize to
# the current time
last_received_rpc = time.time()

# Keep track of the last heartbeat we sent
# this is only relevant when we are the leader
# initialize to -1, will be reset if/when we
# become the leader
last_sent_heartbeat = -1

# Keep track of the replica's term
# all will start at 0
current_term = 0

# Candidate who received this replica's
# vote in the current term
voted_for = None

# If we are in the candidate state, we want
# to keep track of how many votes we have gotten
num_votes = 0

# Current leader, when replicas startup
# leader is unknown so set to 'FFFF'
current_leader = 'FFFF'

# Keep track of a state machine
state_machine = {}

# Keep track of a log, make it an ordered dictionary
log = collections.OrderedDict()

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

#last = 0

while True:
	ready = select.select([sock], [], [], 0.1)[0]
	
	if sock in ready:
		msg_raw = sock.recv(32768)
		
		if len(msg_raw) == 0: continue
		msg = json.loads(msg_raw)
		
		# For now, send back fail message to get and put calls
		if msg['type'] in ['get', 'put']:
                        handle_client_message(msg['type'], msg['MID'], msg['src'], msg)
		
		# Handle noop messages. This may be removed from your final implementation
		#elif msg['type'] == 'noop':
		#	print '%s received a NOOP from %s' % (msg['dst'], msg['src'])

		# Handle a request_vote rpc
		elif msg['type'] == 'request_vote':
			handle_request_vote_messages(msg)
			last_received_rpc = time.time()

		# Handle an append_entries rpc
		elif msg['type'] == 'append_entries':
			handle_append_entries_messages(msg)
			last_received_rpc = time.time()
		
	# Do periodic checks
	clock = time.time()

	# Check if election timeout has occurred
	if not (state == "leader"):
		check_election_timeout(clock)
	# Check if we need to send a heartbeat
	else:
		check_send_heartbeat(clock)


	#if clock-last > 2:
		# Send a no-op message to a random peer every two seconds, just for fun
		# You definitely want to remove this from your implementation
		#msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
		#sock.send(json.dumps(msg))
		#print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
		#last = clock
